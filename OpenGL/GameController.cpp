#include "GameController.h"

#include "Fonts.h"
#include "WindowController.h"
#include "ToolWindow.h"

GameController::GameController()
{
    m_shaderColor = {};
    m_shaderDiffuse = {};
    m_meshes.clear();
    m_meshLight = {};
    m_camera = {};
}

void GameController::Initialize()
{
    GLFWwindow* glfwWindow = WindowController::GetInstance().GetWindow();
    M_ASSERT(glfwWindow != nullptr, "Failed to create GLFW window!");
    
    glewExperimental = GL_TRUE;
    M_ASSERT(glewInit() == GLEW_OK, "Failed to initialize GLEW.");
    glGetError(); // Clear any OpenGL error generated by glewInit
    
    M_ASSERT(glewIsSupported("GL_VERSION_3_3"), "OpenGL 3.3 not supported!");
    
    GLuint vao = 0;
    glGenVertexArrays(1, &vao);
    M_ASSERT(vao != 0, "Failed to create VAO!");
    glBindVertexArray(vao);
    
    glfwSetInputMode(glfwWindow, GLFW_STICKY_KEYS, GL_TRUE); // Ensure we can capture the escape key
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // black background
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_CULL_FACE);
    srand((unsigned int)time(0)); // Seed random number generator

    //Create a default perspective camera
    m_camera = Camera(WindowController::GetInstance().GetResolution());
}

void GameController::RunGame()
{
    // Create and compile our GLSL programs from the shaders
    m_shaderColor = Shader();
    m_shaderColor.LoadShaders("Shaders/Color.vertexshader.txt", "Shaders/Color.fragmentshader.txt");
    
    m_shaderDiffuse = Shader();
    m_shaderDiffuse.LoadShaders("Shaders/Diffuse.vertexshader.txt", "Shaders/Diffuse.fragmentshader.txt");
    
    m_shaderSkybox = Shader();
    m_shaderSkybox.LoadShaders("Shaders/Skybox.vertexshader.txt", "Shaders/Skybox.fragmentshader.txt");
    
    m_shaderFont = Shader();
    m_shaderFont.LoadShaders("Shaders/Font.vertexshader.txt", "Shaders/Font.fragmentshader.txt");

    // Create meshes
    Mesh m = Mesh();
    if (m.Create(&m_shaderColor, "Assets/Models/Teapot.obj"))
    {
        m.SetPosition({1.0f, 0.0f, 0.0f});
        m.SetColor({1.0f, 1.0f, 1.0f});
        m.SetScale({0.01f, 0.01f, 0.01f});
        Mesh::Lights.push_back(m);
    }

    Mesh box = Mesh();
    if (box.Create(&m_shaderDiffuse, "Assets/Models/Cube.obj"))
    {
        box.SetCameraPosition(m_camera.GetPosition());
        box.SetScale({0.5f, 0.5f, 0.5f});
        box.SetPosition({1.0f, 0.0f, 5.0f});
        m_meshes.push_back(box);
    }

    m_skybox = Skybox();
    bool skyboxCreated = m_skybox.Create(&m_shaderSkybox, "Assets/Models/Skybox.obj", {
                      "Assets/Textures/right.jpg",
                      "Assets/Textures/left.jpg",
                      "Assets/Textures/top.jpg",
                      "Assets/Textures/bottom.jpg",
                      "Assets/Textures/front.jpg",
                      "Assets/Textures/back.jpg"
                  });

    Fonts f = Fonts();
    f.Create(&m_shaderFont, "arial.ttf", 40);

    do {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear the screen

        m_camera.Rotate();
        if (skyboxCreated) {
            glm::mat4 view = glm::mat4(glm::mat3(m_camera.GetView())); // Remove translation from the view matrix
            m_skybox.Render(m_camera.GetProjection() * view);
        }

        for (unsigned int count = 0; count < m_meshes.size(); count++)
        {
            m_meshes[count].Render(m_camera.GetProjection() * m_camera.GetView());
        }
        for (unsigned int count = 0; count < Mesh::Lights.size(); count++)
        {
            Mesh::Lights[count].Render(m_camera.GetProjection() * m_camera.GetView());
        }
        f.RenderText("Testing text", 100, 100, 0.5f, {1.0f, 1.0f, 0.0f});

        glfwSwapBuffers(WindowController::GetInstance().GetWindow()); // Swap the back and front buffers
        glfwPollEvents();
    } while (glfwGetKey(WindowController::GetInstance().GetWindow(), GLFW_KEY_ESCAPE) != GLFW_PRESS &&
             glfwWindowShouldClose(WindowController::GetInstance().GetWindow()) == 0);

    for (unsigned int count = 0; count < Mesh::Lights.size(); count++)
    {
        Mesh::Lights[count].Cleanup();
    }
    for (unsigned int count = 0; count < m_meshes.size(); count++)
    {
        m_meshes[count].Cleanup();
    }
    m_skybox.Cleanup();
    m_shaderDiffuse.Cleanup();
    m_shaderColor.Cleanup();
    m_shaderSkybox.Cleanup();
}
